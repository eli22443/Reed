# Reed-Solomon List Decoding (Sudan's Algorithm)

This project implements **Reed-Solomon (RS) Error Correcting Codes** with a specific focus on **List Decoding** using the **Sudan Algorithm**. [cite_start]The implementation demonstrates how list decoding provides enhanced resilience to data corruption compared to traditional unique decoding[cite: 7, 11].

## Table of Contents
- [Problem Definition](#problem-definition)
- [Unique vs. List Decoding](#unique-vs-list-decoding)
- [Algorithm Overview](#algorithm-overview)
    - [Encoding](#encoding)
    - [Decoding (Sudan's Algorithm)](#decoding-sudans-algorithm)
- [Implementation](#implementation)
- [Requirements](#requirements)

---

## Problem Definition
[cite_start]The project addresses the intrinsic unreliability of digital communication and storage channels caused by noise and corruption[cite: 3]. [cite_start]The goal is to encode data so that the original message remains recoverable despite these errors[cite: 4, 6]. [cite_start]Reed-Solomon codes, based on polynomials, are utilized as the primary error-correcting mechanism[cite: 5].

## Unique vs. List Decoding
[cite_start]Traditional **Unique Decoding** corrects errors up to a threshold of $p \le \lfloor (d-1)/2 \rfloor$[cite: 8, 14]. [cite_start]For an RS code with rate $R$, this is limited to $p \le (1-R)/2$ errors[cite: 14]. 

[cite_start]**List Decoding** is a relaxation of this process where the decoder outputs a list of possible messages ($L$)[cite: 9]. [cite_start]Successful decoding occurs if the original message is contained within this list[cite: 10]. [cite_start]This allows the correction of significantly more errors, potentially reaching the Johnson radius ($p = 1 - \sqrt{R}$)[cite: 11, 14].

| Feature | Unique Decoding | List Decoding |
| :--- | :--- | :--- |
| **Output** | [cite_start]A single codeword [cite: 14] | [cite_start]A list of codewords (up to size $L$) [cite: 14] |
| **Error Threshold ($p$)** | [cite_start]$\le (1-R)/2$ [cite: 14] | [cite_start]Up to $1 - \sqrt{R}$ [cite: 14] |
| **Relaxation** | [cite_start]Requires unique closest codeword [cite: 14] | [cite_start]Allows multiple codewords in radius [cite: 14] |

---

## Algorithm Overview

### 1. Encoding
[cite_start]The encoding process interprets a message as a polynomial and evaluates it at specific points[cite: 16]:
- [cite_start]**Input:** A message $m = (m_0, \dots, m_{k-1})$ is interpreted as coefficients of a polynomial $M(x)$ of degree at most $k-1$[cite: 19, 20].
- [cite_start]**Generation:** The codeword is generated by evaluating $M(x)$ at $n$ distinct points $\alpha_1, \dots, \alpha_n$ in a finite field $\mathbb{F}_q$[cite: 18, 21].
- [cite_start]**Parameters:** The resulting code has parameters $[n, k, n-k+1]_q$[cite: 22].

### 2. Decoding (Sudan's Algorithm)
[cite_start]The decoding process, also known as polynomial reconstruction, involves finding all polynomials that agree with the received word at a sufficient number of points $t$[cite: 24, 25]:
- [cite_start]**Interpolation Step:** The algorithm finds a non-zero bivariate polynomial $Q(X, Y)$ that vanishes at all received points $Q(\alpha_i, y_i) = 0$[cite: 28, 30]. [cite_start]This is solved as a homogeneous linear system[cite: 31].
- [cite_start]**Root Finding Step:** If a message polynomial $p(X)$ has high agreement, $Y - p(X)$ must be a factor of $Q(X, Y)$[cite: 32]. [cite_start]The algorithm extracts the list by factoring $Q$[cite: 33].

---

## Implementation
The project is implemented in **Python 3** using:
- **`galois`**: For finite field arithmetic and polynomial operations.
- **`numpy`**: For linear algebra and solving the interpolation system.

[cite_start]The code demonstrates successful message recovery even when the number of errors exceeds the unique decoding threshold[cite: 11, 34].

## Requirements
To run the implementation, install the dependencies:
```bash
pip install galois numpy